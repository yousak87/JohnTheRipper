/*
 * This file is part of John the Ripper password cracker,
 * Copyright (c) 2013 by Solar Designer
 * Copyright (c) 2013 by magnum
 * Copyright (c) 2013 Sayantan Datta <std2048 at gmail dot com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted.
 *
 * There's ABSOLUTELY NO WARRANTY, express or implied.
 */

#include <stdio.h>		/* for fprintf(stderr, ...) */

#include "misc.h"		/* for error() */
#include "logger.h"
#include "recovery.h"
#include "os.h"
#include "signals.h"
#include "status.h"
#include "options.h"
#include "rpp.h"
#include "external.h"
#include "cracker.h"
#include "john.h"
#include "mask.h"
#include "loader.h"

#define MASK_DEBUG 0

static struct mask_context msk_ctx;

/*
 * stores the postion where mask is appended when
 * mask + wordlist mode is used.
 */
unsigned char *mask_offset_buffer;

static struct rpp_context rpp_ctx, rec_ctx;

/*
 * A "sequence number" for distributing the candidate passwords across nodes.
 * It is OK if this number overflows once in a while, as long as this happens
 * in the same way for all nodes (must be same size unsigned integer type).
 */
static unsigned int seq, rec_seq, multiplier = 1;

static int get_progress(int *hundth_perc)
{
	int hundredXpercent, percent;
	unsigned long long try, cand;
	int i;

	i = 0; cand = 1;
	while (rpp_ctx.ranges[i].count)
		cand *= rpp_ctx.ranges[i++].count;

	if (options.node_count)
		cand /= options.node_count;

	try = ((unsigned long long)status.cands.hi << 32) + status.cands.lo;
	try *= multiplier;

	if (!try) {
		hundredXpercent = percent = 0;
		return percent;
	}

	if (!cand)
		return -1;

	if (try > 1844674407370955LL) {
		*hundth_perc = percent = 99;
	} else {
		hundredXpercent = (int)((unsigned long long)(10000 * (try)) / (unsigned long long)cand);
		percent = hundredXpercent / 100;
		*hundth_perc = hundredXpercent - (percent*100);
	}

	return percent;
}

static void save_state(FILE *file)
{
	int i;

	fprintf(file, "%u\n", rec_seq);
	fprintf(file, "%s\n", rec_ctx.output);
	fprintf(file, "%d\n", rec_ctx.count);
	for (i = 0; i < rec_ctx.count; i++)
		fprintf(file, "%d\n", rec_ctx.ranges[i].index);
}

static int restore_state(FILE *file)
{
	int i;

	if (fscanf(file, "%u\n", &seq) != 1)
		return 1;
	if (fscanf(file, "%s\n", rpp_ctx.output) != 1)
		return 1;
	if (fscanf(file, "%d\n", &rpp_ctx.count) != 1)
		return 1;
	for (i = 0; i < rpp_ctx.count; i++)
		if (fscanf(file, "%d\n", &rpp_ctx.ranges[i].index) != 1)
			return 1;
	return 0;
}

static void fix_state(void)
{
	rec_seq = seq;
	rec_ctx = rpp_ctx;
}

/*
 * Calculates nCr combinations recursively.
 * Used to select best combination of mask-placeholders depending
 * upon the required number of keys generated by the format internally.
 */
static void combination_util(void *arr, int data[], int start, int end, int index,
                             int r, int target, int *isOptimal);

/*
 * Checks the placeholder selected by combination_util.
 * If the selected placeholder doesn't have all characters consective and
 * the number of characters in the placeholder exceeds MAX_GPU_CHARS then
 * return 0 otherwise 1.
 */
static int check_range(struct mask_context *ctx, int rangePos) {
	unsigned char start = ctx->ranges[rangePos].chars[0];
	int i;

	/* Check if all values are consecutive in the given range */
	for (i = 1; i < (ctx->ranges[rangePos].count); i++) {
		if (((ctx->ranges[rangePos].chars[i]) - start) == i)
			continue;
		break;
	}

	if (i == (ctx->ranges[rangePos].count)) {
		ctx->ranges[rangePos].start = start;

		return 1;
	}

	for (i = 1; i < (ctx->ranges[rangePos].count); i++) {
		if ((start - (ctx->ranges[rangePos].chars[i])) == i)
			continue;
		break;
	}

	if (i == (ctx->ranges[rangePos].count)) {
		ctx->ranges[rangePos].start = ctx->ranges[rangePos].chars[--i];
		return 1;
	}

	/* If all chars are not consecutive */
	if ((ctx->ranges[rangePos].count) <= MAX_GPU_CHARS) {
		ctx->ranges[rangePos].start = 0;
		return 1;
	}

	return 0;
}

/*
 * check all placeholders selected by calc_combination.
 */
static int check_select_ranges(struct mask_context *ctx, int *data, int r) {
	int i, flag = 1;
	for (i = 0; i < r; i++)
		flag &= check_range(ctx, data[i]);
	return flag;
}

static void calc_combination(void *arr, int n, int target) {
	int data[n], isOptimal = 0x7fffffff, i;
	((struct mask_context *)arr)->count = 0x7fffffff;

	/* Fix the maximum number of ranges that can be calculated on GPU to 3 */
	for (i = 1; i <= MAX_GPU_RANGES; i++)
		combination_util(arr, data, 0, n - 1, 0, i, target,
		                 &isOptimal);

}

static void combination_util(void *arr, int data[], int start, int end, int index,
                             int r, int target, int *isOptimal) {
	int i;

	if (index == r) {
		int j, tmp = 1;
		for (j = 0; j < r; j++)
			tmp *=
				((struct mask_context *)arr)->ranges[data[j]].
				count;
		tmp -= target;
		tmp = tmp < 0 ? -tmp : tmp;

		if (tmp <= *isOptimal) {
			if ((r < ((struct mask_context *)arr)->count) ||
			    (tmp < *isOptimal)) {
				if (!check_select_ranges(((struct mask_context
				                           *)arr), data, r))
					return;
				((struct mask_context *)arr)->count = r;
				for (j = 0; j < r; j++)
					((struct mask_context *)arr)->
						activeRangePos[j] = data[j];
				*isOptimal = tmp;
			}
		}
		return;
	}

	for (i = start; i <= end && end - i + 1 >= r - index; i++) {
		data[index] = i;
		combination_util(arr, data, i + 1, end, index + 1, r, target,
		                 isOptimal);
	}
}

static void set_mask(struct rpp_context *rpp_ctx, struct fmt_main *fmt,
                     unsigned char flg_wrd) {
	int i;

	/*
	 * Copy mask parameters from rpp to mask for furthur
	 * processing.
	 */
	for (i = 0; i < rpp_ctx->count; i++) {
		memcpy(msk_ctx.ranges[i].chars, rpp_ctx->ranges[i].chars,
		       0x100);
		msk_ctx.ranges[i].count = rpp_ctx->ranges[i].count;
		msk_ctx.ranges[i].pos =
			rpp_ctx->ranges[i].pos - rpp_ctx->output;
	}

	calc_combination(&msk_ctx, rpp_ctx->count, fmt->params.num_internal_keys);
	msk_ctx.flg_wrd = flg_wrd;
	memcpy(fmt->private.msk_ctx,
	       &msk_ctx, sizeof(struct mask_context));

#if MASK_DEBUG
	int j;
	for (i = 0; i < msk_ctx.count; i++) {
		for (j = 0;
		     j < msk_ctx.ranges[msk_ctx.activeRangePos[i]].count; j++)
			printf("%c ",
			       msk_ctx.ranges[msk_ctx.activeRangePos[i]].
			       chars[j]);
		printf("\n");
		//checkRange(&msk_ctx, msk_ctx.activeRangePos[i]) ;
		printf("START:%c",
		       msk_ctx.ranges[msk_ctx.activeRangePos[i]].start);
		printf("\n");
	}
#endif
}

void mask_process(struct fmt_main *fmt, char *mask, unsigned char flg_wrd) {

	rpp_init_mask(&rpp_ctx, mask);
	rpp_process_rule(&rpp_ctx);

	if (rpp_ctx.count > MASK_RANGES_MAX) {
		fprintf(stderr,
		        "mask mode error: Increase MASK_RANGES_MAX value to RULE_RANGES_MAX.\n");
		error();
	}

	if (fmt->params.num_internal_keys) {
		int i;
		set_mask(&rpp_ctx, fmt, flg_wrd);
		fmt->params.num_internal_keys = 1;
		for (i = 0; i < msk_ctx.count; i++)
			fmt->params.num_internal_keys *= msk_ctx.ranges[msk_ctx.activeRangePos[i]].count;
	}
	multiplier = fmt->params.num_internal_keys;
}

void do_mask_crack(struct db_main *db, char *mask, char *wordlist) {
	struct rpp_context rpp_ctx_restore;
	char word[128], *mask_word, line[128];
	FILE *file = NULL;
	int flag;
	unsigned int index, length;
	size_t mask_offset;
	int my_words, their_words;

	log_event("Proceeding with mask mode");

	/* --stdout does not use fmt_init() */
	if (rpp_ctx.input == NULL)
		rpp_init_mask(&rpp_ctx, mask);

	seq = 0;

	status_init(&get_progress, 0);

	rpp_process_rule(&rpp_ctx);
	rec_restore_mode(restore_state);
	rec_init(db, save_state);

	crk_init(db, fix_state, NULL);

	my_words = options.node_max - options.node_min + 1;
	their_words = options.node_min - 1;

	if (seq) {
/* Restored session.  seq is right after a word we've actually used. */
		int for_node = seq % options.node_count + 1;
		if (for_node < options.node_min ||
		    for_node > options.node_max) {
/* We assume that seq is at the beginning of other nodes' block */
			their_words = options.node_count - my_words;
		} else {
			my_words = options.node_max - for_node + 1;
			their_words = 0;
		}
	}

	if (wordlist)
		file = fopen((const char *)wordlist, "r");
	else
		file = NULL;

	if (db->format)
		length = db->format->params.max_keys_per_crypt;
	else
		length = 1;

	length = length ? length : 1;

	mask_offset_buffer = (unsigned char *)mem_calloc(length);

	if (file != NULL) {
#if MASK_DEBUG
		fprintf(stdout, "Using:wordlist:%d\n", length);
#endif
		rpp_ctx_restore = rpp_ctx;
		index = 0;
		while (fgets(line, sizeof(line), file) != NULL) {
			memcpy(word, line, 128);
			mask_offset = strlen(word) - 1;
			while ((mask_word =
			        msk_next(&rpp_ctx, &msk_ctx, &flag))) {
				if (options.node_count) {
					seq++;
					if (their_words) {
						their_words--;
						continue;
					}
					if (--my_words == 0) {
						my_words =
							options.node_max - options.node_min + 1;
						their_words = options.node_count - my_words;
					}
				}
				if (ext_filter(mask_word)) {
					memcpy(word + mask_offset, mask_word,
					       MASK_RANGES_MAX);
					mask_offset_buffer[index] =
						mask_offset;
					index++;
					if (index == length)
						index = 0;
					if (crk_process_key(word))
						goto close_file;
				}
			}
			rpp_ctx = rpp_ctx_restore;
			flag = 0;
		}

close_file:
		fclose(file);
	}

	else {
#if MASK_DEBUG
		fprintf(stdout, "NOT Using:wordlist\n");
#endif
		flag = 0;
		while ((mask_word = msk_next(&rpp_ctx, &msk_ctx, &flag))) {
			if (options.node_count) {
				seq++;
				if (their_words) {
					their_words--;
					continue;
				}
				if (--my_words == 0) {
					my_words =
						options.node_max - options.node_min + 1;
					their_words = options.node_count - my_words;
				}
			}
			if (ext_filter(mask_word))
				if (crk_process_key(mask_word))
					break;
		}
	}

	crk_done();
	MEM_FREE(mask_offset_buffer);

	rec_done(event_abort);
}
